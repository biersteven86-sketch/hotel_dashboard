// server.js
const express    = require('express');
const path       = require('path');
const fs         = require('fs');
const session    = require('express-session');
const rateLimit  = require('express-rate-limit');
const nodemailer = require('nodemailer');
const crypto     = require('crypto');
require('dotenv').config({ quiet: true });

// ✅ Reset-Routen modular einbinden (liegen in ./routes.reset.js)
const resetRoutes = require('./routes.reset');

const app  = express();
const PORT = process.env.PORT || 3000;

// ===== Root & Verzeichnisse =====
const ROOT      = process.env.HD_ROOT
  ? path.resolve(process.env.HD_ROOT)
  : path.resolve(__dirname);

const publicDir   = path.join(ROOT, 'public');
const dataDir     = path.join(ROOT, 'data');
const authDir     = path.join(dataDir, 'auth');
const usersPath   = path.join(dataDir, 'users.json');
const tokensPath  = path.join(authDir, 'reset.db.json');
const auditLogPath= path.join(authDir, 'reset_audit.log');

// Verzeichnisse sicherstellen
fs.mkdirSync(publicDir, { recursive: true });
fs.mkdirSync(authDir,   { recursive: true });
fs.mkdirSync(dataDir,   { recursive: true });

// ===== Helper: Token-DB =====
function loadTokens() {
  try {
    const raw = fs.readFileSync(tokensPath, 'utf8');
    const parsed = JSON.parse(raw);
    let tokens = parsed && parsed.tokens;
    if (!Array.isArray(tokens)) tokens = [];
    return { tokens };
  } catch {
    return { tokens: [] };
  }
}
function saveTokens(obj) {
  const out = { tokens: Array.isArray(obj.tokens) ? obj.tokens : [] };
  fs.writeFileSync(tokensPath, JSON.stringify(out, null, 2), 'utf8');
}
function purgeExpiredTokens(db) {
  const now = Date.now();
  db.tokens = db.tokens.filter(t => !t.used && t.expiresAt > now);
}

// ===== Helper: Users-DB =====
function loadUsers() {
  try {
    const raw = fs.readFileSync(usersPath, 'utf8');
    const parsed = JSON.parse(raw);
    let users = parsed && parsed.users;
    if (!Array.isArray(users)) users = [];
    return { users };
  } catch {
    return { users: [] };
  }
}
function saveUsers(obj) {
  const out = { users: Array.isArray(obj.users) ? obj.users : [] };
  fs.writeFileSync(usersPath, JSON.stringify(out, null, 2), 'utf8');
}
function hashPassword(password, salt = crypto.randomBytes(16).toString('hex')) {
  const iterations = 310000;
  const keylen = 32;
  const digest = 'sha256';
  const hash = crypto.pbkdf2Sync(password, salt, iterations, keylen, digest).toString('hex');
  return { algo: `pbkdf2:${digest}:${iterations}`, salt, hash };
}
function verifyPassword(password, user) {
  if (!user?.passHash || !user?.passSalt) return false;
  const parts = String(user.passAlgo || '').split(':'); // pbkdf2:sha256:310000
  const iterations = Number(parts[2] || 310000);
  const digest = parts[1] || 'sha256';
  const keylen = 32;
  const test = crypto.pbkdf2Sync(password, user.passSalt, iterations, keylen, digest).toString('hex');
  return crypto.timingSafeEqual(Buffer.from(test, 'hex'), Buffer.from(user.passHash, 'hex'));
}

// ===== Express Basics =====
app.set('trust proxy', 1);
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.use(session({
  secret: process.env.SESSION_SECRET || 'change-me-please',
  resave: false,
  saveUninitialized: false,
  cookie: { httpOnly: true, sameSite: 'lax', secure: false, maxAge: 60 * 60 * 1000 }
}));

// RateLimit nur auf POST /login
const loginLimiter = rateLimit({
  windowMs: 5 * 60 * 1000,
  max: 50,
  standardHeaders: true,
  legacyHeaders: false
});

// Statische Assets zuerst
app.use(express.static(publicDir, { index: false }));

// ✅ Neue Reset-Routen aktivieren (aus externer Datei)
app.use(resetRoutes);

// ===== Guards =====
const OPEN_PATHS = new Set([
  '/', '/login', '/health',
  '/reset', '/reset.html',
  '/reset/validate', '/reset/confirm'   // bleiben offen, werden von routes.reset.js bedient
]);
const assetRE = /\.(?:png|jpe?g|gif|svg|ico|webp|css|js|map)$/i;

app.use((req, res, next) => {
  if (assetRE.test(req.path)) return next();
  if (OPEN_PATHS.has(req.path)) return next();
  if (req.path.startsWith('/public/')) return next();
  if (req.session && req.session.user) return next();
  return res.redirect('/login');
});

// Direkte .html Aufrufe blocken (außer login/reset)
app.use((req, res, next) => {
  if (req.path.endsWith('.html') && req.path !== '/login.html' && req.path !== '/reset.html') {
    return res.redirect('/login');
  }
  next();
});

// ===== Routen: öffentlich =====
app.get ('/', (_req, res) => res.redirect('/login'));
app.head('/', (_req, res) => res.set('Location', '/login').sendStatus(302));

app.get ('/login', (_req, res) => res.sendFile('login.html', { root: publicDir }));
app.head('/login', (_req, res) => res.sendStatus(200));

app.get ('/reset', (_req, res) => res.sendFile('reset.html', { root: publicDir }));
app.head('/reset', (_req, res) => res.sendStatus(200));

// Reset anstoßen: Token erzeugen + Mail
app.post('/reset', async (req, res) => {
  try {
    const email = String(req.body.email || '').trim().toLowerCase();
    if (!email) return res.status(400).type('text').send('E-Mail fehlt');

    const token = Math.random().toString(36).slice(2, 10);
    const now   = Date.now();
    const exp   = now + 30 * 60 * 1000; // 30 Min

    const db = loadTokens();
    purgeExpiredTokens(db);
    db.tokens = db.tokens.filter(t => t.email !== email);
    db.tokens.push({ email, token, createdAt: now, expiresAt: exp, used: false });
    saveTokens(db);

    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: parseInt(process.env.SMTP_PORT || '587', 10),
      secure: String(process.env.SMTP_SECURE || 'false') === 'true',
      auth: { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS },
      tls: { rejectUnauthorized: false }
    });

    const appBase = process.env.APP_BASE_URL || `http://localhost:${PORT}`;
    const verifyUrl = `${appBase}/reset?token=${encodeURIComponent(token)}&email=${encodeURIComponent(email)}`;

    const info = await transporter.sendMail({
      from: `"Passwort-Service" <${process.env.SMTP_USER}>`,
      to: email,
      subject: 'Passwort zurücksetzen',
      text:
`Hallo,

wir haben eine Anfrage zum Zurücksetzen deines Passworts erhalten.
Dein Code lautet: ${token}

Oder klicke:
${verifyUrl}

Der Code ist 30 Minuten gültig.
Falls du das nicht warst, kannst du diese Nachricht ignorieren.`,
      html:
`<p>Hallo,</p>
<p>wir haben eine Anfrage zum Zurücksetzen deines Passworts erhalten.</p>
<p>Dein Code lautet: <b>${token}</b></p>
<p>Oder klicke: <a href="${verifyUrl}">${verifyUrl}</a></p>
<p>Der Code ist 30&nbsp;Minuten gültig.<br>Falls du das nicht warst, kannst du diese Nachricht ignorieren.</p>`
    });

    console.log('✅ Reset-Mail verschickt:', info.messageId, '→', email);
    return res.type('text').send('Reset-Mail verschickt. Bitte Postfach prüfen.');
  } catch (err) {
    console.error('❌ Fehler /reset:', err && (err.stack || err));
    return res.status(500).type('text').send('Mailversand fehlgeschlagen');
  }
});

// ===== Routen: geschützt =====
function requireAuth(req, res, next) {
  if (req.session && req.session.user) return next();
  return res.redirect('/login');
}

app.get('/index',  requireAuth, (_req, res) => res.sendFile('index.html',  { root: publicDir }));
app.get('/ibelsa', requireAuth, (_req, res) => res.sendFile('ibelsa.html', { root: publicDir }));

// Login prüfen (inkl. users.json)
app.post('/login', loginLimiter, (req, res) => {
  const { username, password } = req.body || {};
  const name = String(username || '').trim();
  const pass = String(password || '');

  const ud = loadUsers();
  const nameLower = name.toLowerCase();
  const user = ud.users.find(u =>
    (u.email && u.email.toLowerCase() === nameLower) ||
    (u.username && u.username.toLowerCase() === nameLower)
  );
  if (user && verifyPassword(pass, user)) {
    req.session.user = name;
    return res.redirect('/after-login');
  }

  // .env Fallback (bestehende Admin-/Spezial-Accounts)
  const {
    DASH_USER = '', DASH_PASS = '',
    ADMIN_USER = '', ADMIN_PASS = '',
    IBELSA_USER = '', IBELSA_PASS = ''
  } = process.env;

  const ok =
    (name === DASH_USER   && pass === DASH_PASS)   ||
    (name === ADMIN_USER  && pass === ADMIN_PASS)  ||
    (name === IBELSA_USER && pass === IBELSA_PASS);

  if (!ok) return res.redirect('/login?err=1');
  req.session.user = name;
  return res.redirect('/after-login');
});

// Nach Login verteilen
app.get('/after-login', (req, res) => {
  const u = (req.session && req.session.user) ? String(req.session.user) : '';
  const adminUser = (process.env.ADMIN_USER || 'admin').toLowerCase();
  if (u && u.toLowerCase() === adminUser) return res.redirect('/index');
  return res.redirect('/ibelsa');
});

// Health
app.get ('/health', (_req, res) => res.type('text').send('OK'));
app.head('/health', (_req, res) => res.sendStatus(200));

// 404 → Login (Assets fängt static oben ab)
app.use((_req, res) => res.status(404).sendFile('login.html', { root: publicDir }));

// Fehlerhandler
app.use((err, _req, res, _next) => {
  console.error('[server] Fehler:', err && err.stack || err);
  res.status(500).type('text').send('Internal Server Error');
});

// Start
app.listen(PORT, () => {
  console.log('Hotel-Dashboard läuft auf Port', PORT);
  console.log('ROOT      :', ROOT);
  console.log('publicDir :', publicDir);
  console.log('users.json:', usersPath);
  console.log('tokens    :', tokensPath);
  console.log('audit log :', auditLogPath);
});
