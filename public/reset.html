// server.js
const express    = require('express');
const path       = require('path');
const fs         = require('fs');
const session    = require('express-session');
const rateLimit  = require('express-rate-limit');
const nodemailer = require('nodemailer');
const crypto     = require('crypto');
require('dotenv').config({ quiet: true });

const app  = express();
const PORT = process.env.PORT || 3000;

// ===== Root & Verzeichnisse =====
const ROOT      = process.env.HD_ROOT
  ? path.resolve(process.env.HD_ROOT)
  : path.resolve(__dirname);

const publicDir   = path.join(ROOT, 'public');
const dataDir     = path.join(ROOT, 'data');
const authDir     = path.join(dataDir, 'auth');
const usersPath   = path.join(dataDir, 'users.json');
const tokensPath  = path.join(authDir, 'reset.db.json');
const auditLogPath= path.join(authDir, 'reset_audit.log');

// Verzeichnisse sicherstellen
fs.mkdirSync(publicDir, { recursive: true });
fs.mkdirSync(authDir,   { recursive: true });
fs.mkdirSync(dataDir,   { recursive: true });

// ===== Helper: Token-DB =====
function loadTokens() {
  try {
    const raw = fs.readFileSync(tokensPath, 'utf8');
    const parsed = JSON.parse(raw);
    let tokens = parsed && parsed.tokens;
    if (!Array.isArray(tokens)) tokens = [];
    return { tokens };
  } catch {
    return { tokens: [] };
  }
}
function saveTokens(obj) {
  const out = { tokens: Array.isArray(obj.tokens) ? obj.tokens : [] };
  fs.writeFileSync(tokensPath, JSON.stringify(out, null, 2), 'utf8');
}
function purgeExpiredTokens(db) {
  const now = Date.now();
  db.tokens = db.tokens.filter(t => !t.used && t.expiresAt > now);
}

// ===== Helper: Users-DB =====
function loadUsers() {
  try {
    const raw = fs.readFileSync(usersPath, 'utf8');
    const parsed = JSON.parse(raw);
    let users = parsed && parsed.users;
    if (!Array.isArray(users)) users = [];
    return { users };
  } catch {
    return { users: [] };
  }
}
function saveUsers(obj) {
  const out = { users: Array.isArray(obj.users) ? obj.users : [] };
  fs.writeFileSync(usersPath, JSON.stringify(out, null, 2), 'utf8');
}
function hashPassword(password, salt = crypto.randomBytes(16).toString('hex')) {
  const iterations = 310000;
  const keylen = 32;
  const digest = 'sha256';
  const hash = crypto.pbkdf2Sync(password, salt, iterations, keylen, digest).toString('hex');
  return { algo: `pbkdf2:${digest}:${iterations}`, salt, hash };
}
function verifyPassword(password, user) {
  if (!user?.passHash || !user?.passSalt) return false;
  const parts = String(user.passAlgo || '').split(':'); // pbkdf2:sha256:310000
  const iterations = Number(parts[2] || 310000);
  const digest = parts[1] || 'sha256';
  const keylen = 32;
  const test = crypto.pbkdf2Sync(password, user.passSalt, iterations, keylen, digest).toString('hex');
  return crypto.timingSafeEqual(Buffer.from(test, 'hex'), Buffer.from(user.passHash, 'hex'));
}

// ===== Express Basics =====
app.set('trust proxy', 1);
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.use(session({
  secret: process.env.SESSION_SECRET || 'change-me-please',
  resave: false,
  saveUninitialized: false,
  cookie: { httpOnly: true, sameSite: 'lax', secure: false, maxAge: 60 * 60 * 1000 }
}));

// RateLimit nur auf POST /login
const loginLimiter = rateLimit({
  windowMs: 5 * 60 * 1000,
  max: 50,
  standardHeaders: true,
  legacyHeaders: false
});

// Statische Assets zuerst
app.use(express.static(publicDir, { index: false }));

// ===== Guards =====
const OPEN_PATHS = new Set([
  '/', '/login', '/health',
  '/reset', '/reset.html',
  '/reset/validate', '/reset/confirm'
]);
const assetRE = /\.(?:png|jpe?g|gif|svg|ico|webp|css|js|map)$/i;

app.use((req, res, next) => {
  if (assetRE.test(req.path)) return next();
  if (OPEN_PATHS.has(req.path)) return next();
  if (req.path.startsWith('/public/')) return next();
  if (req.session && req.session.user) return next();
  return res.redirect('/login');
});

// Direkte .html Aufrufe blocken (außer login/reset)
app.use((req, res, next) => {
  if (req.path.endsWith('.html') && req.path !== '/login.html' && req.path !== '/reset.html') {
    return res.redirect('/login');
  }
  next();
});

// ===== Routen: öffentlich =====
app.get ('/', (_req, res) => res.redirect('/login'));
app.head('/', (_req, res) => res.set('Location', '/login').sendStatus(302));

app.get ('/login', (_req, res) => res.sendFile('login.html', { root: publicDir }));
app.head('/login', (_req, res) => res.sendStatus(200));

app.get ('/reset', (_req, res) => res.sendFile('reset.html', { root: publicDir }));
app.head('/reset', (_req, res) => res.sendStatus(200));

// Reset anstoßen: Token erzeugen + Mail
app.post('/reset', async (req, res) => {
  try {
    const email = String(req.body.email || '').trim().toLowerCase();
    if (!email) return res.status(400).type('text').send('E-Mail fehlt');

    const token = Math.random().toString(36).slice(2, 10);
    const now   = Date.now();
    const exp   = now + 30 * 60 * 1000; // 30 Min

    const db = loadTokens();
    purgeExpiredTokens(db);
    db.tokens = db.tokens.filter(t => t.email !== email);
    db.tokens.push({ email, token, createdAt: now, expiresAt: exp, used: false });
    saveTokens(db);

    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: parseInt(process.env.SMTP_PORT || '587', 10),
      secure: String(process.env.SMTP_SECURE || 'false') === 'true',
      auth: { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS },
      tls: { rejectUnauthorized: false }
    });

    const appBase = process.env.APP_BASE_URL || `http://localhost:${PORT}`;
    const verifyUrl = `${appBase}/reset?token=${encodeURIComponent(token)}&email=${encodeURIComponent(email)}`;

    const info = await transporter.sendMail({
      from: `"Passwort-Service" <${process.env.SMTP_USER}>`,
      to: email,
      subject: 'Passwort zurücksetzen',
      text:
`Hallo,

wir haben eine Anfrage zum Zurücksetzen deines Passworts erhalten.
Dein Code lautet: ${token}

Oder klicke:
${verifyUrl}

Der Code ist 30 Minuten gültig.
Falls du das nicht warst, kannst du diese Nachricht ignorieren.`,
      html:
`<p>Hallo,</p>
<p>wir haben eine Anfrage zum Zurücksetzen deines Passworts erhalten.</p>
<p>Dein Code lautet: <b>${token}</b></p>
<p>Oder klicke: <a href="${verifyUrl}">${verifyUrl}</a></p>
<p>Der Code ist 30&nbsp;Minuten gültig.<br>Falls du das nicht warst, kannst du diese Nachricht ignorieren.</p>`
    });

    console.log('✅ Reset-Mail verschickt:', info.messageId, '→', email);
    return res.type('text').send('Reset-Mail verschickt. Bitte Postfach prüfen.');
  } catch (err) {
    console.error('❌ Fehler /reset:', err && (err.stack || err));
    return res.status(500).type('text').send('Mailversand fehlgeschlagen');
  }
});

// Token prüfen
app.get('/reset/validate', (req, res) => {
  const token = String(req.query.token || '').trim();
  const email = String(req.query.email || '').trim().toLowerCase();
  if (!token || !email) return res.status(400).json({ ok:false, msg:'token/email fehlt' });

  const db = loadTokens();
  const now = Date.now();
  const rec = db.tokens.find(t => t.email === email && t.token === token && !t.used && t.expiresAt > now);
  if (!rec) return res.status(404).json({ ok:false, msg:'ungültig oder abgelaufen' });

  return res.json({ ok:true, msg:'valid' });
});
app.head('/reset/validate', (_req, res) => res.sendStatus(200));

// Passwort endgültig setzen
app.post('/reset/confirm', (req, res) => {
  try {
    const token     = String(req.body.token || '').trim();
    const emailRaw  = String(req.body.email || '').trim();
    const email     = emailRaw.toLowerCase();
    const password  = String(req.body.password || '');
    const firstname = String(req.body.firstname || '').trim();
    const lastname  = String(req.body.lastname || '').trim();

    if (!token || !email || !password || !firstname || !lastname) {
      return res.status(400).type('text').send('Pflichtfelder fehlen');
    }

    // Stärkeprüfung
    const strong = (
      password.length >= 10 &&
      /[A-Z]/.test(password) &&
      /[a-z]/.test(password) &&
      (/\d/.test(password) || /[^A-Za-z0-9]/.test(password))
    );
    if (!strong) return res.status(422).type('text').send('Passwort zu schwach');

    const db = loadTokens();
    const now = Date.now();
    const idx = db.tokens.findIndex(t => t.email === email && t.token === token && !t.used && t.expiresAt > now);
    if (idx === -1) return res.status(403).type('text').send('Token ungültig/abgelaufen');

    // Token als benutzt markieren
    db.tokens[idx].used = true;
    purgeExpiredTokens(db);
    saveTokens(db);

    // Audit-Log
    const audit = {
      ts: new Date().toISOString(),
      email,
      firstname,
      lastname,
      ip: (req.headers['x-forwarded-for'] || req.socket.remoteAddress || '').toString()
    };
    fs.appendFileSync(auditLogPath, JSON.stringify(audit) + '\n');

    // User anlegen/aktualisieren
    const ud = loadUsers();
    const uIdx = ud.users.findIndex(u => (u.email || '').toLowerCase() === email);
    const { algo, salt, hash } = hashPassword(password);
    const username = emailRaw.split('@')[0];

    if (uIdx === -1) {
      ud.users.push({
        email,
        username,
        firstname,
        lastname,
        role: "user", // Standardrolle
        passAlgo: algo,
        passSalt: salt,
        passHash: hash,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
    } else {
      ud.users[uIdx] = {
        ...ud.users[uIdx],
        firstname,
        lastname,
        passAlgo: algo,
        passSalt: salt,
        passHash: hash,
        updatedAt: new Date().toISOString()
      };
    }
    saveUsers(ud);

    return res.type('text').send('Passwort gesetzt');
  } catch (err) {
    console.error('❌ Fehler /reset/confirm:', err && (err.stack || err));
    return res.status(500).type('text').send('Fehler beim Setzen des Passworts');
  }
});

// ===== Routen: geschützt =====
function requireAuth(req, res, next) {
  if (req.session && req.session.user) return next();
  return res.redirect('/login');
}
function requireAdmin(req, res, next) {
  if (req.session && req.session.user && req.session.role === 'admin') return next();
  return res.redirect('/login?err=unauthorized');
}

app.get('/index',  requireAuth, (_req, res) => res.sendFile('index.html',  { root: publicDir }));
app.get('/ibelsa', requireAuth, (_req, res) => res.sendFile('ibelsa.html', { root: publicDir }));

// Admin-Bereich
app.get('/admin', requireAdmin, (_req, res) => {
  res.type('text').send('Admin-Dashboard – hier später Logs/Kundenverwaltung einbauen');
});

// Login prüfen (nur users.json)
app.post('/login', loginLimiter, (req, res) => {
  const { username, password } = req.body || {};
  const name = String(username || '').trim();
  const pass = String(password || '');

  const ud = loadUsers();
  const nameLower = name.toLowerCase();
  const user = ud.users.find(u =>
    (u.email && u.email.toLowerCase() === nameLower) ||
    (u.username && u.username.toLowerCase() === nameLower)
  );
  if (user && verifyPassword(pass, user)) {
    req.session.user = name;
    req.session.role = user.role || "user";
    return res.redirect('/after-login');
  }

  return res.redirect('/login?err=1');
});

// Nach Login verteilen
app.get('/after-login', (req, res) => {
  const role = req.session?.role || "user";
  if (role === "admin") return res.redirect('/admin');
  return res.redirect('/index');
});

// Health
app.get ('/health', (_req, res) => res.type('text').send('OK'));
app.head('/health', (_req, res) => res.sendStatus(200));

// 404 → Login
app.use((_req, res) => res.status(404).sendFile('login.html', { root: publicDir }));

// Fehlerhandler
app.use((err, _req, res, _next) => {
  console.error('[server] Fehler:', err && err.stack || err);
  res.status(500).type('text').send('Internal Server Error');
});

// Start
app.listen(PORT, () => {
  console.log('Hotel-Dashboard läuft auf Port', PORT);
  console.log('ROOT      :', ROOT);
  console.log('publicDir :', publicDir);
  console.log('users.json:', usersPath);
  console.log('tokens    :', tokensPath);
  console.log('audit log :', auditLogPath);
});
